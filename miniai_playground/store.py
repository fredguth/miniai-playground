# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/store.ipynb.

# %% ../nbs/store.ipynb 2
from __future__ import annotations
from typing import List, Callable, TypeVar,  Generic, Sequence

# %% auto 0
__all__ = ['T', 'subscriber_queue', 'Subscriber', 'Unsubscriber', 'Updater', 'Readable', 'Writable', 'writable', 'readable']

# %% ../nbs/store.ipynb 4
T = TypeVar("T")


class Subscriber(Generic[T]):
    def __call__(self, value: T) -> None:
        ...
class Unsubscriber:
    def __call__(self) -> None:
        ...

class Updater(Generic[T]):
    def __call__(self, value: T) -> T:
        ...


class Readable(Generic[T]):
    def subscribe(self, subscriber: Subscriber[T]) -> Unsubscriber:
        ...

class Writable(Readable, Generic[T]):
    def set(self, value: T) -> None:
        ...
    def update(self, updater: Updater[T]) -> None:
        ...

subscriber_queue: List[Subscriber] = [] # callback list

# %% ../nbs/store.ipynb 5
def writable(value: T) -> Writable[T]:
    """ Create a writable store with a given value that allows both updating and reading by subscription."""

    def __getitem__(*args, **kwargs): return value.__getitem__(*args, **kwargs) if hasattr(value, '__getitem__') else None

    def set(new_value: T) -> None:
        nonlocal value
        if new_value != value: value = new_value
        for subscriber in subscriber_queue: subscriber(value)

    def update(fn: Updater[T]) -> None: set(fn(value))

    def subscribe(subscriber: Subscriber[T]) -> Unsubscriber:
        subscriber_queue.append(subscriber)
        subscriber(value)

        def unsubscribe() -> None:
            subscriber_queue.remove(subscriber)

        return unsubscribe

    ret = Writable() # type: ignore
    ret.set = set # type: ignore
    ret.update = update # type: ignore
    ret.subscribe = subscribe

    return ret

# %% ../nbs/store.ipynb 6
def readable(value: T) -> Readable[T]:
    ret = Readable()
    ret.subscribe = writable(value).subscribe
    return ret
